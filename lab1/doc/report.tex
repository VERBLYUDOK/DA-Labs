\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискретного анализа: сортировка за линейное время}

Выполнил студент группы М8О-203Б-23 МАИ \textit{Арусланов Кирилл}.

\subsection*{Условие}

\subsubsection*{Общая постановка задачи}
Требуется разработать программу, которая осуществляет ввод пар \textit{ключ-значение}, упорядочивает их по возрастанию ключа с помощью алгоритма сортировки за линейное время и выводит отсортированную последовательность.

\subsubsection*{Вариант задания}
\begin{itemize}
    \item \textbf{Тип ключа}: почтовые индексы (целые числа).
    \item \textbf{Тип значения}: строки переменной длины (до 2048 символов).
    \item \textbf{Алгоритм сортировки}: сортировка подсчётом.
\end{itemize}

Пример ввода:
\begin{verbatim}
000000  xGfxrxGGxrxMMMMfrrrG
999999  xGfxrxGGxrxMMMMfrrr
000000  xGfxrxGGxrxMMMMfrr
999999  xGfxrxGGxrxMMMMfr
\end{verbatim}

Пример вывода:
\begin{verbatim}
000000  xGfxrxGGxrxMMMMfrrrG
000000  xGfxrxGGxrxMMMMfrr
999999  xGfxrxGGxrxMMMMfrrr
999999  xGfxrxGGxrxMMMMfr
\end{verbatim}

\subsection*{Метод решения}

Для решения задачи применяется алгоритм сортировки подсчётом, который эффективен для целочисленных ключей в ограниченном диапазоне (в данном случае 000000--999999). Алгоритм включает следующие шаги:
\begin{enumerate}
    \item Инициализация вектора счётчиков размером \texttt{MAX\_KEY = 1000000}.
    \item Подсчёт количества вхождений каждого ключа.
    \item Накопление счётчиков для определения позиций элементов.
    \item Формирование отсортированного массива.
\end{enumerate}

Сложность алгоритма составляет $O(n + k)$, где $n$ --- число элементов, а $k = 1000000$ --- диапазон ключей. Поскольку $k$ фиксировано, общая сложность является линейной относительно $n$.

\subsection*{Описание программы}

Программа реализована в одном файле и включает следующие компоненты:

\begin{itemize}
    \item \textbf{Структура \texttt{Item}:}  
    Определяет пару \textit{ключ-значение}:
    \begin{itemize}
        \item \texttt{key} --- тип \texttt{size\_t} (почтовый индекс).
        \item \texttt{value} --- тип \texttt{std::string} (строка до 2048 символов).
    \end{itemize}

    \item \textbf{Функция \texttt{countingSort}:}  
    Реализует сортировку подсчётом. Использует вектор \texttt{cntVect} размером \texttt{MAX\_KEY} для хранения счётчиков. Принимает вектор элементов \texttt{Item} и возвращает отсортированный вектор.

    \item \textbf{Функция \texttt{main}:}  
    Считывает пары \textit{ключ-значение} из стандартного ввода, вызывает \texttt{countingSort} и выводит результат с форматированием ключей (6 цифр с ведущими нулями).
\end{itemize}

\textbf{Используемые библиотеки:} \texttt{<iostream>}, \texttt{<vector>}, \texttt{<string>}, \texttt{<iomanip>}.

\subsection*{Дневник отладки}

Во время разработки программа не проходила 13-й тест из-за превышения лимита времени. Изначально планировалось использовать функцию \texttt{maxKey} для динамического определения максимального ключа, что требовало дополнительного прохода по данным. Для оптимизации было решено задать фиксированное значение \texttt{MAX\_KEY = 1000000}, соответствующее диапазону почтовых индексов. После этого изменения программа успешно прошла все тесты.

\subsection*{Тест производительности}

Для сравнения производительности алгоритмов \texttt{countingSort} и \texttt{std::sort} были проведены тесты на различных объемах входных данных: $n = 1000$, $10000$, $50000$, $100000$, $500000$, $1000000$. Время выполнения и потребление памяти измерялись с использованием случайных данных: ключи в диапазоне 000000--999999, строки \texttt{value} случайной длины до 2048 символов. Результаты представлены в таблице:

\begin{tabular}{|c|c|c|c|c|}
\hline
$n$       & Время \texttt{countingSort} (мс) & Время \texttt{std::sort} (мс) & Память \texttt{countingSort} (Мб) & Память \texttt{std::sort} (Мб) \\ \hline
1000      & 39                               & 0                             & 7.67                              & 0.04                           \\ 
10000     & 14                               & 3                             & 8.01                              & 0.38                           \\ 
50000     & 14                               & 14                            & 9.54                              & 1.91                           \\ 
100000    & 26                               & 33                            & 11.44                             & 3.81                           \\ 
500000    & 100                              & 194                           & 26.70                             & 19.07                          \\ 
1000000   & 200                              & 470                           & 45.78                             & 38.15                          \\ \hline
\end{tabular}

Анализ показывает, что на малых объемах данных ($n \leq 10000$) \texttt{std::sort} работает быстрее: например, для $n = 1000$ его время составляет 0 мс против 39 мс у \texttt{countingSort}. Это связано с большими накладными расходами \texttt{countingSort} на инициализацию вектора счётчиков размером \texttt{MAX\_KEY = 1000000}. Однако на средних и больших объемах данных ($n \geq 100000$) \texttt{countingSort} становится быстрее благодаря линейной сложности $O(n + k)$: для $n = 1000000$ его время составляет 200 мс против 470 мс у \texttt{std::sort}, что в 2.35 раза быстрее. Потребление памяти у \texttt{countingSort} всегда выше из-за дополнительного вектора счётчиков и результирующего вектора: для $n = 1000000$ он использует 45.78 Мб против 38.15 Мб у \texttt{std::sort}. Таким образом, \texttt{countingSort} предпочтителен для больших данных с ограниченным диапазоном ключей, тогда как \texttt{std::sort} лучше подходит для малых данных или случаев с ограниченной памятью.

\subsection*{Недочёты}

После оптимизации с использованием константы \texttt{MAX\_KEY} недочётов не выявлено. Все тесты пройдены успешно.

\subsection*{Выводы}

Сортировка подсчётом применима для задач с ограниченным диапазоном ключей, таких как сортировка почтовых индексов или идентификаторов. Алгоритм показал линейную сложность и высокую эффективность. Основная трудность заключалась в оптимизации времени работы, решённая отказом от динамического поиска максимального ключа. Программирование оказалось умеренно сложным из-за необходимости точной реализации алгоритма.

\end{document}